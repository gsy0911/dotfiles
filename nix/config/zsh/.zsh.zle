# Setup colors
autoload -Uz colors && colors

# 1) Prefix 用キーマップを作る
# udk_zsh:= user-defined-kymap zsh
bindkey -N udk_zsh

# 2) Prefix に入るウィジェット
function zle-enter-prefix() {
  zle -K udk_zsh
  # ステータスラインにメッセージを表示 (意図してprintfを使っている)
  printf "\n$Red + UDK-ZSH$Rst:\tn:nvim | r: repo | t: task | z: zellij"
}
zle -N zle-enter-prefix

# 3) Cancel widget
# Esc でキャンセルして main に戻る
function prefix-cancel() {
  zle -K main
  zle -M "" 
}
zle -N prefix-cancel
bindkey -M udk_zsh '\e' prefix-cancel

# 4) Prefix キー（例: Ctrl-a）
bindkey '^a' zle-enter-prefix

# --- Custom Widgets ---

# fzf-task-command-copy
function tl() {
    # zle -I # 外部コマンド実行前に画面をクリア
    
    # taskコマンドの出力を取得
    local src=$(task | grep -v "Available tasks for" | fzf)
    
    if [ -z "$src" ]; then
        # キャンセルされた場合
        zle -K main
        zle redisplay
        return
    fi

    local selected=$(echo $src | cut -d' ' -f2)
    local selectedCommand=${selected%?}
    
    if [ -n "$selectedCommand" ]; then
        # クリップボードにコピー
        echo -n "task $selectedCommand" | pbcopy
        
        # Descriptionの抽出と表示
        local desc=$(echo $src | awk -F'[:*]' '{print $3}' | sed 's/^ *//')
	# 意図してprintfを使っている（メッセージを消したくないため）
        printf "\n$Grn * DESC:$Rst\t$desc\n\n"

        # taskfile-parserを使って実際のコマンドを展開
        local command=$(uvx --from git+https://github.com/gsy0911/taskfile-parser parser --pwd $(pwd) --taskfile-task-name $selectedCommand)
        BUFFER=$command
    fi
    
    zle -K main
}
zle -N tl
bindkey -M udk_zsh 't' tl

function open-neovim() {
    zle -I
    nvim
    zle accept-line
}
zle -N open-neovim
bindkey -M udk_zsh 'n' open-neovim

# fzf-ghq
# see: https://zenn.dev/mozumasu/articles/mozumasu-lazy-git
function fzf-ghq() {
  zle -I
  local src=$(ghq list | fzf --preview "bat --color=always --style=header,grid --line-range :80 $(ghq root)/{}/README.*")
  if [ -n "$src" ]; then
    BUFFER="cd $(ghq root)/$src"
    zle accept-line
  else
    zle redisplay
  fi
  zle -K main
}
zle -N fzf-ghq
bindkey -M udk_zsh 'r' fzf-ghq

function fzf-zellij-attach() {
  zle -I
  local session=$(zellij list-sessions --short | fzf)
  if [ -n "$session" ]; then
    BUFFER="zellij attach $session"
    zle accept-line
  else
    zle redisplay
  fi
  zle -K main
}
zle -N fzf-zellij-attach
bindkey -M udk_zsh 'z' fzf-zellij-attach

autoload -Uz read-from-minibuffer
function ask-reply() {
  local reply=""
  if ! read-from-minibuffer "Input> "; then
    zle -K main
    return 1
  fi
  BUFFER=$REPLY
  zle accept-line
  zle -K main
}
zle -N ask-reply
bindkey -M udk_zsh 'x' ask-reply
